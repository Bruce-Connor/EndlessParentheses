---
title: "Mold Slack entirely to your liking with Emacs"
date: 2017-10-09 23:43:00
layout: post
categories: 
tags: 
- slack 
- init.el
published: true
comments: 
series: "Slack"
---
<p>
Although <a href="/keep-your-slack-distractions-under-control-with-emacs.html">fine-tuning your slack notifications</a> is already reason enough to run
slack in Emacs, that’s only the beginning. Once everything is up and running
<b>you</b> get to decide what you want out of your slack. Some of the snippets below
simply make up for missing functionality, other customize the package beyond
what you can do on the Slack Webapp.
</p>

<p>
Priorities first. The most important improvement you can implement is install
<a href="https://github.com/iqbalansari/emacs-emojify">emojify-mode</a> and turn it on for slack chats.
</p>
{% highlight emacs-lisp %}
(add-hook 'slack-mode-hook #'emojify-mode)
{% endhighlight %}
<p>
Secondly, make sure you costumize the chat faces to your liking. Just open a
chat buffer, place your cursor on a piece of text whose face you want to
customize, and call <a href="http://doc.endlessparentheses.com/Fun/customize-face"><code>customize-face</code></a>.
</p>

<p>
In order to keep track of new messages in the mode-line, slack.el uses a package
called tracking, which is the same one <a href="https://github.com/jorgenschaefer/circe">circe</a> uses for IRC chats. The command
<a href="http://doc.endlessparentheses.com/Fun/tracking-next-buffer"><code>tracking-next-buffer</code></a> is a fantastic way to cycle through your pending
messages, bind it to something short.
</p>
{% highlight emacs-lisp %}
(with-eval-after-load 'tracking
  (define-key tracking-mode-map [f11]
    #'tracking-next-buffer))
;; Ensure the buffer exists when a message arrives on a
;; channel that wasn't open.
(setq slack-buffer-create-on-notify t)
{% endhighlight %}

<p>
I’ll never know who thought user statuses were a good idea for Slack. But, thanks 
to a tip by <a href="https://news.ycombinator.com/item?id=15277244">_asummers on HackerNews</a>, I can live in a world where they don’t exist.
</p>
{% highlight emacs-lisp %}
(defun slack-user-status (_id _team) "")
{% endhighlight %}

<p>
I like notifications with minimal titles, and the package is kind enough to make
these configurable.
</p>
{% highlight emacs-lisp %}
;;; Channels
(setq slack-message-notification-title-format-function
      (lambda (_team room threadp)
        (concat (if threadp "Thread in #%s") room)))

(defun endless/-cleanup-room-name (room-name)
  "Make group-chat names a bit more human-readable."
  (replace-regexp-in-string
   "--" " "
   (replace-regexp-in-string "#mpdm-" "" room-name)))

;;; Private messages and group chats
(setq
 slack-message-im-notification-title-format-function
 (lambda (_team room threadp)
   (concat (if threadp "Thread in %s") 
           (endless/-cleanup-room-name room))))
{% endhighlight %}

<p>
Slack.el uses lui for the chat buffers. If you, like me, are a <a href="/ispell-and-abbrev-the-perfect-auto-correct.html">heavy user of
abbrevs</a> in Emacs, you’ll find it annoying that the final word of each message
won’t get expanded unless you explicitly hit <kbd>SPC</kbd> before <kbd>RET</kbd>. That’s easy to
remedy with an advice.
</p>
{% highlight emacs-lisp %}
(advice-add #'lui-send-input :before
            (lambda (&rest _)
              (ignore-errors (expand-abbrev))))
{% endhighlight %}

<p>
Finally, the biggest missing feature from this package is that it displays the
author on every message output, even when the same user sends several messages
in a row. The snippet below adds a hook to omit the author name for a message
whenever it’s the same author as the previous message.
</p>
{% highlight emacs-lisp %}
(defun endless/-author-at (pos)
  (replace-regexp-in-string
   (rx "\n" (* anything)) ""
   (or (get-text-property pos 'lui-raw-text) "")))

(defun endless/-remove-slack-author ()
  "Remove author here if it's the same as above."
  (let ((author-here (endless/-author-at (point)))
        (author-above (endless/-author-at (1- (point)))))
    (when (and (looking-at-p (regexp-quote author-here))
               (equal author-here author-above))
      (delete-region (1- (point))
                     (1+ (line-end-position))))))

(defun endless/remove-slack-author-hook ()
  "For usage in `lui-pre-output-hook'."
  (when (derived-mode-p 'slack-mode)
    (save-excursion
      (goto-char (point-min))
      (save-restriction
        (widen)
        (endless/-remove-slack-author)))))

(add-hook 'lui-pre-output-hook
          #'endless/remove-slack-author-hook)
{% endhighlight %}

<p>
You don’t have to stop here, of course. Want to fine-tune which buffers get
tracked on the mode-line? Hack into <code>tracking.el</code>. Want to change the face used
for your own messages, or even align them to the right? Redefine
<code>slack-buffer-insert</code>. Your workflow is yours to build.</p>
