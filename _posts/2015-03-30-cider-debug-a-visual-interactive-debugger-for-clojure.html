---
title: "Cider-debug, a visual, interactive, debugger for Clojure"
date: 2015-03-30
layout: post
tags: programming debugging clojure
---
<p>
Over the last couple of weeks, I’ve been working on a Clojure debugger for <a href="https://github.com/clojure-emacs/cider">Cider</a>
that is strongly inspired by Edebug. Stepping trough code of any form and
injecting values into running code are the features available in this first
release.
</p>

<p>
This little project started shortly after I my first practical delve into
Clojure. I was impressed at how well Cider integrated Clojure into Emacs, it
almost felt like writing Elisp! When <a href="https://twitter.com/bbatsov/status/574112622167068672">Bozhidar mentioned</a> that they were in need
of a debugger, I figured that’d be as a good a chance as any to practice some
Clojure. Since my praise for Edebug <a href="/debugging-emacs-lisp-part-1-earn-your-independence.html">is no secret</a> around here, it should come as
no surprise that I’d model <code>cider-debug</code> after it (albeit, a bit more limited).
</p>

<p>
I should also mention the <a href="https://github.com/razum2um/clj-debugger">clj-debugger</a> plugin, upon which <code>cider-debug</code> is
built. They were happy to <a href="https://github.com/razum2um/clj-debugger/pulls?q=is%253Apr+is%253Aclosed">drop some extra dependencies</a> in order to help out
Cider.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Usage</h2>
<div class="outline-text-2" id="text-1">
<p>
First, if you’re still using <a href="http://stable.melpa.org/#/cider"><code>cider</code> 0.8</a> (which is the latest stable release),
you’ll need to upgrade to the snapshot version <a href="http://melpa.org/#/cider"><code>cider</code> 0.9</a>, which is available
on Melpa. Additionally, ensure your “~/.lein/profiles.clj” file is consistent
with that.
</p>

{% highlight clojure %}
{:user {:plugins [[cider/cider-nrepl "0.9.0-SNAPSHOT"]]}}
{% endhighlight %}

<p>
Once that is done, using <code>cider-debug</code> could hardly be more straightforward.
Just instrument an expression with <kbd>C-u C-M-x</kbd>, and you’ll be taken through the
code step-by-step. There, you can move on with <kbd>n</kbd>, quit with <kbd>q</kbd>, or inject
values with <kbd>i</kbd>. Note that if you instrument a <code>defn</code> the debugger will not
start immediately, instead, you’ll be taken to the debugger each time the
function is executed.
</p>

<p>
This sort of thing is easier to explain with a gif.
</p>


<div class="figure">
<p><img src="/images/cider-debug.gif" alt="cider-debug.gif" />
</p>
</div>

<p>
That’s really all there is to it for now. There are plans to introduce more
sophisticated navigation commands &#x2014;such as <a href="/debugging-elisp-part-2-advanced-topics.html">Edebug’s <kbd>o</kbd> and <kbd>h</kbd></a>&#x2014; and some
other fundamentals like evaluating code in the current scope. But, for now, we’d
very much appreciate the feedback of any Clojurists out there. <a href="https://github.com/clojure-emacs/cider/issues">File an issue</a> if
you spot something, or just share your thoughts with us on <a href="http://twitter.com/AMalabarba">Twitter</a> or <a href="https://gitter.im/clojure-emacs/cider">Gitter</a>.
</p>
</div>
</div>
